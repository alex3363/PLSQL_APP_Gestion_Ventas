CREATE OR REPLACE TRIGGER TG_ACTUALIZA_BITACORA_SUELDO
AFTER UPDATE OF sueldo_base ON vendedor
FOR EACH ROW
DECLARE
    V_ANTIGUO_SUELDO NUMBER;
    V_NUEVO_SUELDO NUMBER;
    V_VARIACION NUMBER;
BEGIN
    FOR UPDATED_ROW IN ( --PRIMER CURSOR implicito para recorrer los registros actualizados
        SELECT :NEW.sueldo_base AS NUEVO_SUELDO,
               :OLD.sueldo_base AS ANTIGUO_SUELDO,
               :NEW.rutvendedor AS RUT_VENDEDOR
        FROM dual
    ) LOOP
        -- variables para el sueldo anterior y nuevo de la fila actualizada
        V_ANTIGUO_SUELDO := UPDATED_ROW.ANTIGUO_SUELDO;
        V_NUEVO_SUELDO := UPDATED_ROW.NUEVO_SUELDO;

        -- Calcular la variacion
        V_VARIACION := V_NUEVO_SUELDO - V_ANTIGUO_SUELDO;

        -- Insertar en la tabla bitacora
        BEGIN
            IF V_VARIACION <> 0 THEN --PRIMER CONDICIONAL PARA CONSIDERAR INSERT UNA VEZ VERIFICADA VARIACION DE SUELDO
                INSERT INTO bitacora (id_bitacora, rutvendedor, anterior, actual, variacion)
                VALUES (SEQ_BITACORA.NEXTVAL, UPDATED_ROW.RUT_VENDEDOR, V_ANTIGUO_SUELDO, V_NUEVO_SUELDO, V_VARIACION);
            END IF;
        EXCEPTION
            WHEN DUP_VAL_ON_INDEX THEN
                 pkg_repuestos_car.SP_ERRORES(SQLERRM, 'valores duplicados al realizar insert');
        END;
    END LOOP;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        PKG_REPUESTOS_CAR.SP_ERRORES(SQLERRM, 'No se encontraron datos');
END TG_ACTUALIZA_BITACORA_SUELDO;
/



-- PARA REALIZAR UPDATE EN VENDEDOR COMO PRUEBA
UPDATE vendedor
SET sueldo_base = 500000
WHERE rutvendedor = '10656569-K';
COMMIT;

UPDATE vendedor
SET sueldo_base = 450000
WHERE rutvendedor = '12456778-1';
COMMIT;

-- PARA REVISAR LOS CAMBIOS EN LAS TABLAS VENDEDOR Y BITACORA
SELECT sueldo_base
FROM vendedor
WHERE rutvendedor = '10656569-K';

SELECT sueldo_base
FROM vendedor
WHERE rutvendedor = '12456778-1';

SELECT *
FROM bitacora;









CREATE OR REPLACE PACKAGE PKG_REPUESTOS_CAR AS
    -- 3 VARIABLES PUBLICAS, UNA PARA ALMACENAR DE ACUERDO AL ANIO, Y VARIABLES PARA UN CONTEO DE ERRORES Y BOLETAS DE ACUERDO AL PROCESO
    G_ANIO_PROCESO NUMBER;
    G_TOTAL_ERRORES VARCHAR2(100);
    G_NUMERO_BOLETAS NUMBER; 
  
    FUNCTION CALCULAR_APORTE_VENDEDOR(P_RUTVENDEDOR IN VARCHAR2) RETURN NUMBER;

    -- PROCEDIMIENTO PUBLICO PARA REGISTRAR ERRORES
    PROCEDURE SP_ERRORES (
        DESCRIPCION_VAR_IN IN ERROR_PROCESOS_MENSUALES.DESCRIP_ERROR%TYPE,
        MENSAJE_ORACLE_VAR_IN IN ERROR_PROCESOS_MENSUALES.RUTINA_ERROR%TYPE
    );

END PKG_REPUESTOS_CAR;
/




CREATE OR REPLACE PACKAGE BODY PKG_REPUESTOS_CAR AS

    -- FUNCION PARA DADO EL RUT DEL VENDEDOR, ENTREGA LA CANTIDAD EN BOLETAS RESPECTO AL ANIO PROCESADO
    FUNCTION CALCULAR_APORTE_VENDEDOR(P_RUTVENDEDOR IN VARCHAR2) RETURN NUMBER IS
    V_MONTO_VENTAS NUMBER;
    V_SQL VARCHAR2(1000); -- Variable para la consulta dinamica
    BEGIN
    --SQL DINAMICO PARA RECUPERAR INFORMACION DE TABLAS PARA PROCEDIMIENTO
    V_SQL := 'SELECT NVL(SUM(total), 0) FROM boleta WHERE rutvendedor = :1 AND TO_NUMBER(TO_CHAR(FECHA, ''YYYY'')) = :2';
    
    EXECUTE IMMEDIATE V_SQL INTO V_MONTO_VENTAS USING P_RUTVENDEDOR, PKG_REPUESTOS_CAR.G_ANIO_PROCESO;
    
    
        SELECT COUNT(*) -- Se ocupa variable G_NUMERO_BOLETAS para realizar conteo de acuerdo a anio ingresado
        INTO G_NUMERO_BOLETAS
        FROM boleta
        WHERE TO_NUMBER(TO_CHAR(FECHA, 'YYYY')) = G_ANIO_PROCESO;


    -- Retornar el resultado de la consulta
    RETURN NVL(V_MONTO_VENTAS, 0);
EXCEPTION
    WHEN OTHERS THEN
        -- Manejar cualquier error que pueda ocurrir durante la ejecucion de la consulta dinamica
        PKG_REPUESTOS_CAR.SP_ERRORES(SQLERRM, 'CALCULAR_APORTE_VENDEDOR');
        RETURN 0; -- Otra accion apropiada en caso de error

    END CALCULAR_APORTE_VENDEDOR;

   PROCEDURE SP_ERRORES( --PROCEDIMIENTO PUBLICO PARA MANEJO DE ERRORES
       DESCRIPCION_VAR_IN IN ERROR_PROCESOS_MENSUALES.DESCRIP_ERROR%TYPE,
       MENSAJE_ORACLE_VAR_IN IN ERROR_PROCESOS_MENSUALES.RUTINA_ERROR%TYPE
    ) IS
        V_SQL VARCHAR2(1000); --USO DE SQL DINAMIC PARA POBLAR TABLA DE ERRORES EN PROCEDIMIENTO PUBLICO
                 
    BEGIN
        V_SQL := 'INSERT INTO ERROR_PROCESOS_MENSUALES (CORREL_ERROR, RUTINA_ERROR, DESCRIP_ERROR) ' ||
                 'VALUES (SEQ_ERROR.NEXTVAL, :1, :2)';
        EXECUTE IMMEDIATE V_SQL USING MENSAJE_ORACLE_VAR_IN, DESCRIPCION_VAR_IN;
            
        G_TOTAL_ERRORES := 0; --INICIAR VARIABLE EN 0
            
        SELECT NVL(COUNT(CORREL_ERROR), 0) -- G_TOTAL_ERRORES se ocupa variable publica para conteo de errores en el proceso en total    
        INTO G_TOTAL_ERRORES
        FROM ERROR_PROCESOS_MENSUALES;
            
          
            
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLCODE || ' MESSAGE: ' || SQLERRM);
    END SP_ERRORES;

END PKG_REPUESTOS_CAR;
/

-- FUNCION PARA OBTENER EL MONTO TOTAL EN BOLETAS DE ACUERDO A ANIO EN PROCESO
CREATE OR REPLACE FUNCTION OBTENER_MONTO_TOTAL_VENTAS(P_ANIO IN NUMBER) RETURN NUMBER IS
    V_TOTAL_VENTAS NUMBER;
BEGIN
    -- Consulta para obtener el monto total de ventas de boletas para el anio dado
    SELECT NVL(SUM(total), 0) 
    INTO V_TOTAL_VENTAS
    FROM boleta
    WHERE TO_NUMBER(TO_CHAR(FECHA, 'YYYY')) = P_ANIO
    AND P_ANIO = PKG_REPUESTOS_CAR.G_ANIO_PROCESO;

    IF V_TOTAL_VENTAS IS NULL THEN  --SEGUNDA CONDICIONAL IF, Si no se encontraron ventas para el anio especificado, retornar 0

        RETURN 0;
    ELSE
        RETURN V_TOTAL_VENTAS;
    END IF;
    
    EXCEPTION
        WHEN OTHERS THEN
            PKG_REPUESTOS_CAR.SP_ERRORES(SQLERRM, 'OBTENER_MONTO_TOTAL_VENTAS');
END OBTENER_MONTO_TOTAL_VENTAS;
/




-- PROCEDIMIENTO PRINCIPAL DONDE TRABAJAREMOS CON VALORES DE PACKAGE Y FUNCION EXTERNA
CREATE OR REPLACE PROCEDURE GENERAR_INFORME_PORCENTAJE_VENDEDOR IS
    CURSOR CR_INFORME_VENDEDOR (V_ANIO_IN NUMBER) IS -- SEGUNDO CURSOR, EXPLICITO PARA RECORRER CON VARIABLE ANIO
       SELECT
            TO_NUMBER(TO_CHAR((SELECT MAX(FECHA) FROM BOLETA), 'YYYY')) AS ANIO,  -- SE REALIZA SUBCONSULTA EN LA TABLA BOLETA PARA TRABAJAR ESCENCIALMENTE CON TABLA VENDEDOR Y COMUNA SOLAMENTE
            V.RUTVENDEDOR AS RUTVENDEDOR,
            V.NOMBRE AS NOMVENDEDOR,
            C.DESCRIPCION AS COMUNA,
            V.SUELDO_BASE AS SUELDO_BASE
    
        FROM 
            VENDEDOR V
        JOIN 
            COMUNA C ON V.CODCOMUNA = C.CODCOMUNA
        WHERE TO_NUMBER(TO_CHAR((SELECT MAX(FECHA) FROM BOLETA), 'YYYY')) = V_ANIO_IN;

    -- DECLARACION DE VARIABLES PARA INSERT Y ERRORES
    VR_RUTVENDEDOR VARCHAR2(10);
    VR_NOMBRE VARCHAR2(30);
    VR_COMUNA VARCHAR2(60);
    VR_SUELDO_BASE NUMBER(8,0);
    VR_ANIO NUMBER(4,0);
    VR_APORTE_VENTAS NUMBER(5,2);
    V_ERROR_SQL VARCHAR2(1000);
    V_SQL VARCHAR2(1000);

BEGIN
    V_ERROR_SQL := 'TRUNCATE TABLE ERROR_PROCESOS_MENSUALES'; -- SE REALIZA TRUNCATE TABLE CON SQL DINAMICO
    EXECUTE IMMEDIATE V_ERROR_SQL;
    -- Recorrer los vendedores
    FOR FILA_VAR IN CR_INFORME_VENDEDOR (PKG_REPUESTOS_CAR.G_ANIO_PROCESO) LOOP
        BEGIN
         
            VR_ANIO := FILA_VAR.ANIO;
            VR_RUTVENDEDOR := FILA_VAR.RUTVENDEDOR;
            VR_NOMBRE := FILA_VAR.NOMVENDEDOR;
            VR_COMUNA := FILA_VAR.COMUNA;
            VR_SUELDO_BASE := FILA_VAR.SUELDO_BASE;
            VR_APORTE_VENTAS := PKG_REPUESTOS_CAR.CALCULAR_APORTE_VENDEDOR(VR_RUTVENDEDOR)/OBTENER_MONTO_TOTAL_VENTAS(PKG_REPUESTOS_CAR.G_ANIO_PROCESO);
           
            CASE -- TERCR USO DE CONDICIONAL, ESTE CASE SE CREA PARA TRABAJAR LA DIVISION POR 0
                -- Si el monto total de ventas es 0, asignar 0 al porcentaje
                WHEN OBTENER_MONTO_TOTAL_VENTAS(PKG_REPUESTOS_CAR.G_ANIO_PROCESO) = 0 THEN
                    VR_APORTE_VENTAS := 0;
                -- Si el monto total de ventas es mayor que 0, calcular el porcentaje normalmente
                ELSE
                    VR_APORTE_VENTAS := PKG_REPUESTOS_CAR.CALCULAR_APORTE_VENDEDOR(VR_RUTVENDEDOR)/OBTENER_MONTO_TOTAL_VENTAS(PKG_REPUESTOS_CAR.G_ANIO_PROCESO);
            END CASE;
            
            V_SQL :=  --SQL DINAMIC PARA POBLAR TABLA, NO SE OCUPA EN FUNCION PUBLICA PORQUE INTRUCCIONES NO INDICAN GENERAR OTRA FUNCION PARA INSERT SINO DIRECTO DESDE PROCEDIMIENTO
                'INSERT INTO PORCENTAJE_VENDEDOR ( ' || 
                '    ANIO, RUTVENDEDOR, NOMVENDEDOR, ' ||
                '    COMUNA, SUELDO_BASE, APORTE_VENTAS ' ||
                ') VALUES ( ' ||
                '    :1, :2, :3, ' ||
                '    :4, :5, :6 ' ||
                ')';
                
            EXECUTE IMMEDIATE V_SQL USING
                VR_ANIO, VR_RUTVENDEDOR, VR_NOMBRE,
                VR_COMUNA, VR_SUELDO_BASE, VR_APORTE_VENTAS;

        EXCEPTION
            WHEN OTHERS THEN
                PKG_REPUESTOS_CAR.SP_ERRORES(SQLERRM, 'GENERAR_INFORME_PORCENTAJE_VENDEDOR');
        END;
    END LOOP;
   
END GENERAR_INFORME_PORCENTAJE_VENDEDOR;
/

SET SERVEROUTPUT ON --PARA PODER VER EN CONSOLA EL CONTEO DE BOLETAS DE ACUERDO A ANIO INGRESADO Y LOS ERRORES ENCONTRADOS EN PROCESO
BEGIN
    -- SETEAR EL ANIO EN LAS VARIABLES PUBLICAS DEL PACKAGE
    PKG_REPUESTOS_CAR.G_ANIO_PROCESO := 2022; -- ANIO PARA EL CUAL DESEAS GENERAR EL INFORME
    
    -- EJECUCION PARA GENERAR INFORME E INSERTAR REGISTROS
    GENERAR_INFORME_PORCENTAJE_VENDEDOR;
    DBMS_OUTPUT.PUT_LINE('Errores encontrados luego de ejecutado informe: ' || PKG_REPUESTOS_CAR.G_TOTAL_ERRORES);
    DBMS_OUTPUT.PUT_LINE('Cantidad de boletas registradas anio en procesado: ' || PKG_REPUESTOS_CAR.G_NUMERO_BOLETAS);
END;
/

--LOS 12 ERRORES APARECERAN UNA VEZ DE EJECUTE EL MISMO ANIO 2 VECES
SELECT * FROM PORCENTAJE_VENDEDOR;
SELECT * FROM ERROR_PROCESOS_MENSUALES;
